#pragma once

// ** Framework v0.4
#include <Windows.h>
#include <iostream>
#include <vector>
#include <list>
#include <map>

using namespace std;

#include "Constant.h"
#include "enum.h"


// ** 11. 포인터(복습) & 캡슐화

// 데이터와 기능이 하나로 묶여있는 상태를 캡슐화라 한다.
//** Inline
// 클레스 내부에 선언을 하면 인라인 함수가 자동으로 된다.
// 인라인 함수 >> 함수 대기열을 줄여준다, (우선순위)
// 빠르게 실행될 수 있도록 도와주는 것이다.
// 허나 무조건 인라인 함수로 표현하는 것은 좋지않다.

//** [포인터]
//** 1. * 데이터, & 주소반환 연산자
//** 2. 확신이 안차고 포인터 변수라면 [동적할당] 을 우선 한다.
//** 3. 클레스 & 구조체는 [.](점) 아니면 [->](화살표) 로 접근

//** 4. [동적할당] 했다면 반드시 무조건 [할당해제] 해야한다.
//     - 할당해제를 하지 않았다면 메모리 누수가 생기기 때문에.
//       즉 메모리 관리는 철저히 해야한다.
//
//    Java와 C#은 C, C++에 비해 쓰레기통에 정보를 보관해 두다가 다 찼을때 버리기 때문에
//    속도가 상대적으로 느리다.
//    

//** const 상수화 키워드
//  무언가를 상수로 만들고 싶을 때 (상수 -> 변경되지 않는 값)
//  즉, const는 이 부분은 값이 변경되지 않아야한다. 라고 선언할 때
//  쓰는 이유는 다른 프로그래머한테 조심해달라 하는 표현
// 
//** & 사용 시기
//   이항연산 일때 & 연산자는 비트 연산자이다.
//   && 일때는 논리연산(AND)으로 쓰인다. 
//   단항으로 쓰이고, 변수의 앞에 붙으면 주소반환 연산자로 사용된다.
//   레퍼런스 연산자(int&)로 데이터 타입에 붙는다. 해당하는 그 값을 그대로 가져온다.
//    - 기존의 콜 바이 레퍼런스보다 더 빠르다.
//     
//Parent* pParent = new Child1;
//        대입연산자 기준
//   스택영역   |    힙


//** Singleton
// 관리자로 쓸 것 하나만 만들어야한다. 외부에서 만들 수 없는 상태여야한다.
// 생성자를 private에 둔다.
// 데이터를 언제든지 어디서나 쓸 수 있게 만드는
// 실생활에서는 서버실이다

/*
{
    Parent* pParent = new Child1;
    delete pParent;   // 할당해제를 꼭 해야한다.
}

pParent    // 메모리 누수
*/
//

